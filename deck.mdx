import { Appear, Head } from 'mdx-deck';
import { CodeSurferLayout } from "code-surfer";
import "prismjs/components/prism-java";
import "prismjs/components/prism-scala";

import { Graphviz } from "./Graphviz";
import { Railroad, Red } from "./Railroad";
import rr from "railroad-diagrams";

import { github } from "code-surfer";

import { dark, prism } from 'mdx-deck/themes';
import myTheme from './myTheme';

export const themes = [prism, myTheme];

import "./custom.css";

import contributors from "./contributors.png";

# Scala 3, type inference and you!

Guillaume Martres - EPFL

---

# Scala compiler pipeline

<Graphviz dot={[
`
digraph {
bgcolor=transparent;
rankdir=LR;
node [fontsize="38.0", fontname="Source Sans Pro, Noto Color Emoji", shape="box"];
magic [label="âœ¨ Magic âœ¨", style="filled", fillcolor="#d6c8ff"];
src [label="Hello.scala", shape="note", style="filled", fillcolor="#f8f3d4"];
dst [label="Hello.class", shape="note", style="filled", fillcolor="#f8f3d4"];
{ rank=same src magic dst }
src -> magic -> dst;
}
`,
`
digraph {
bgcolor=transparent;
rankdir=LR;
node [fontsize="38.0", fontname="Source Sans Pro, Noto Color Emoji", shape="box"];
magic [label="âœ¨ Magic âœ¨", style="filled", fillcolor="#d6c8ff"];
src [label="Hello.scala", shape="note", style="filled", fillcolor="#f8f3d4"];
dst [label="Hello.class", shape="note", style="filled", fillcolor="#f8f3d4"];
Parser [ style="bold", color="#ef4b4b"];
{ rank=same src Parser }
{ rank=same magic dst }
src -> Parser -> magic -> dst;
}
`,
]} />

---

# Parsing

<Graphviz dot={[
`
digraph {
margin=1.0;
bgcolor=transparent;
labelloc="t";
fontname="Fira Mono";
fontsize="50.0";
label=< <b>foo</b>  <b>.elem(5)</b>  >;
}
`,
`
digraph {
margin=1.0;
bgcolor=transparent;
rankdir=TB;
node [shape="box", fontname="Source Sans Pro, Noto Color Emoji", fontsize="38.0", style="rounded, filled", fillcolor="#cde498"];
foo [label="\\\"foo\\\"", style="filled", fontcolor="#b36232"]
Ident -> foo
labelloc="t";
fontname="Fira Mono";
fontsize="50.0";
label=< <b>foo</b>  >;
}
`,
`
digraph {
margin=0.5;
bgcolor=transparent;
rankdir=TB;
node [shape="box", fontname="Source Sans Pro, Noto Color Emoji", fontsize="38.0", style="rounded, filled"];
foo [label="\\\"foo\\\"", style="filled", fontcolor="#b36232"]
Ident -> foo
node [fillcolor="#cde498"];
elem [label="\\\"elem\\\"", style="filled", fontcolor="#b36232"]
Select -> Ident
Select -> elem
labelloc="t";
fontname="Fira Mono";
fontsize="50.0";
label=<             <b>foo.elem</b>                    >;
}
`,
`
digraph {
bgcolor=transparent;
rankdir=TB;
node [shape="box", fontname="Source Sans Pro, Noto Color Emoji", fontsize="38.0", style="rounded, filled"];
foo [label="\\\"foo\\\"", style="filled", fontcolor="#b36232"]
Ident -> foo
elem [label="\\\"elem\\\"", style="filled", fontcolor="#b36232"]
Select -> Ident
Select -> elem
node [fillcolor="#cde498"];
5 [style="filled", fontcolor="#b36232"]
  Apply -> Select
Apply -> Literal -> 5
labelloc="t";
fontname="Fira Mono";
fontsize="50.0";
label=<             <b>foo.elem(5)</b>                    >;
}
`,
]} />

---

<Graphviz dot={[
`
digraph {
bgcolor=transparent;
rankdir=LR;
node [fontsize="38.0", fontname="Source Sans Pro, Noto Color Emoji", shape="box"];
magic [label="âœ¨ Magic âœ¨", style="filled", fillcolor="#d6c8ff"];
src [label="Hello.scala", shape="note", style="filled", fillcolor="#f8f3d4"];
dst [label="Hello.class", shape="note", style="filled", fillcolor="#f8f3d4"];
{ rank=same src Parser }
{ rank=same magic dst }
src -> Parser -> magic -> dst;
}
`,
`
digraph {
bgcolor=transparent;
rankdir=LR;
node [fontsize="38.0", fontname="Source Sans Pro, Noto Color Emoji", shape="box"];
magic [label="âœ¨ Magic âœ¨", style="filled", fillcolor="#d6c8ff"];
src [label="Hello.scala", shape="note", style="filled", fillcolor="#f8f3d4"];
dst [label="Hello.class", shape="note", style="filled", fillcolor="#f8f3d4"];
Typer [ style="bold", color="#ef4b4b"];
{ rank=same src Parser }
{ rank=same magic dst }
src -> Parser -> Typer -> magic -> dst;
}
`,
]} />

---

# Typing

```scala
class A {
  def elem(x: Int): Int
  def elem(x: String): String
}
val foo: A
// Expression to type
foo.elem(5)
```

---

# Typing

<Graphviz dot={[
`
digraph {
bgcolor=transparent;
rankdir=TB;
node [shape="box", fontname="Source Sans Pro, Noto Color Emoji", fontsize="38.0", style="rounded, filled"];
foo [label="\\\"foo\\\"", style="filled", fontcolor="#b36232"]
Ident -> foo
elem [label="\\\"elem\\\"", style="filled", fontcolor="#b36232"]
Select -> Ident
Select -> elem
5 [style="filled", fontcolor="#b36232"]
Apply -> Select
Apply -> Literal
Literal -> 5
}
`,
`
digraph {
bgcolor=transparent;
rankdir=TB;
node [shape="box", fontname="Source Sans Pro, Noto Color Emoji", fontsize="38.0", style="rounded, filled"];
foo [label="\\\"foo\\\"", style="filled", fontcolor="#b36232"]
Ident -> foo
elem [label="\\\"elem\\\"", style="filled", fontcolor="#b36232"]
Select -> Ident
Select -> elem
5 [style="filled", fontcolor="#b36232"]
Apply -> Select [color="#ef4b4b", fontcolor="#ef4b4b", label="?(...)"];
Apply -> Literal
Literal -> 5
}
`,
`
digraph {
bgcolor=transparent;
rankdir=TB;
node [shape="box", fontname="Source Sans Pro, Noto Color Emoji", fontsize="38.0", style="rounded, filled"];
foo [label="\\\"foo\\\"", style="filled", fontcolor="#b36232"]
Ident -> foo
elem [label="\\\"elem\\\"", style="filled", fontcolor="#b36232"]
Select -> Ident [color="#ef4b4b"];
Select -> elem
5 [style="filled", fontcolor="#b36232"]
Apply -> Select [color="#ef4b4b", fontcolor="#ef4b4b", label="?(...)"];
Apply -> Literal
Literal -> 5
}
`,
`
digraph {
bgcolor=transparent;
rankdir=TB;
node [shape="box", fontname="Source Sans Pro, Noto Color Emoji", fontsize="38.0", style="rounded, filled"];
foo [label="\\\"foo\\\"", style="filled", fontcolor="#b36232"]
    Ident [shape="record", label="Ident | foo.type", fillcolor="#fae3d9"]
Ident -> foo
elem [label="\\\"elem\\\"", style="filled", fontcolor="#b36232"]
Select -> Ident [color="#ef4b4b", fontcolor="#ef4b4b", label="?.elem"];
Select -> elem
5 [style="filled", fontcolor="#b36232"]
Apply -> Select [color="#ef4b4b", fontcolor="#ef4b4b", label="?(...)"];
Apply -> Literal
Literal -> 5
}
`,
`
digraph {
bgcolor=transparent;
rankdir=TB;
node [shape="box", fontname="Source Sans Pro, Noto Color Emoji", fontsize="38.0", style="rounded, filled"];
foo [label="\\\"foo\\\"", style="filled", fontcolor="#b36232"]
Ident [shape="record", label="Ident | foo.type", fillcolor="#fae3d9"]
Select [shape="record", label="Select | foo.elem.type", fillcolor="#fae3d9"]
Ident -> foo
elem [label="\\\"elem\\\"", style="filled", fontcolor="#b36232"]
Select -> Ident;
Select -> elem
5 [style="filled", fontcolor="#b36232"]
Apply -> Select [color="#ef4b4b", fontcolor="#ef4b4b", label="?(...)"];
Apply -> Literal
Literal -> 5
}
`,
`
digraph {
bgcolor=transparent;
rankdir=TB;
node [shape="box", fontname="Source Sans Pro, Noto Color Emoji", fontsize="38.0", style="rounded, filled"];
foo [label="\\\"foo\\\"", style="filled", fontcolor="#b36232"]
Ident [shape="record", label="Ident | foo.type", fillcolor="#fae3d9"]
Select [shape="record", label="Select | foo.elem.type", fillcolor="#fae3d9"]
Literal [shape="record", label="Literal | 5", fillcolor="#fae3d9"]
Ident -> foo
elem [label="\\\"elem\\\"", style="filled", fontcolor="#b36232"]
Select -> Ident;
Select -> elem
5 [style="filled", fontcolor="#b36232"]
Apply -> Select [color="#ef4b4b", fontcolor="#ef4b4b", label="?(Int)"];
Apply -> Literal;
Literal -> 5
}
`,
`
digraph {
bgcolor=transparent;
rankdir=TB;
node [shape="box", fontname="Source Sans Pro, Noto Color Emoji", fontsize="38.0", style="rounded, filled"];
foo [label="\\\"foo\\\"", style="filled", fontcolor="#b36232"]
Ident [shape="record", label="Ident | foo.type", fillcolor="#fae3d9"]
Select [shape="record", label="Select | foo.elem.type", fillcolor="#fae3d9"]
Literal [shape="record", label="Literal | 5", fillcolor="#fae3d9"]
Ident -> foo
elem [label="\\\"elem\\\"", style="filled", fontcolor="#b36232"]
Select -> Ident;
Select -> elem
5 [style="filled", fontcolor="#b36232"]
Apply -> Select [color="#ef4b4b", fontcolor="#ef4b4b", label="?(Int)"];
Apply -> Literal;
Literal -> 5
}
`,
`
digraph {
bgcolor=transparent;
rankdir=TB;
node [shape="box", fontname="Source Sans Pro, Noto Color Emoji", fontsize="38.0", style="rounded, filled"];
foo [label="\\\"foo\\\"", style="filled", fontcolor="#b36232"]
Ident [shape="record", label="Ident | foo.type", fillcolor="#fae3d9"]
Select [shape="record", label="Select | foo.elem.type \\(Int \\=\\> Int\\)", fillcolor="#fae3d9"]
Literal [shape="record", label="Literal | 5", fillcolor="#fae3d9"]
Ident -> foo
elem [label="\\\"elem\\\"", style="filled", fontcolor="#b36232"]
Select -> Ident;
Select -> elem
5 [style="filled", fontcolor="#b36232"]
Apply -> Select;
Apply -> Literal;
Literal -> 5
}
`,
`
digraph {
bgcolor=transparent;
rankdir=TB;
node [shape="box", fontname="Source Sans Pro, Noto Color Emoji", fontsize="38.0", style="rounded, filled"];
foo [label="\\\"foo\\\"", style="filled", fontcolor="#b36232"]
Ident [shape="record", label="Ident | foo.type", fillcolor="#fae3d9"]
Select [shape="record", label="Select | foo.elem.type", fillcolor="#fae3d9"]
Literal [shape="record", label="Literal | 5", fillcolor="#fae3d9"]
Apply [shape="record", label="Apply | Int", fillcolor="#fae3d9"]
Ident -> foo
elem [label="\\\"elem\\\"", style="filled", fontcolor="#b36232"]
Select -> Ident;
Select -> elem
5 [style="filled", fontcolor="#b36232"]
Apply -> Select
Apply -> Literal
Literal -> 5
}
`,
]} />

---

# What if there's a type mismatch ?

<ul>
  The <b>computed type</b> of a tree might not match its <b
  style="color: #ef4b4b;">expected type</b>.<br/>
  <Appear>
    <span>When this happens, the typechecker will attempt to <b style="color: #91b029;">adapt</b> the tree.</span>
    <li><span style="font-family: Fira Mono;">List<span style="color: #ef4b4b;">(1, 2)</span></span></li>
    <li><span style="font-family: Fira Mono;">â†³List<span style="color: #91b029;">.apply</span><span style="color: #ef4b4b;">(1, 2)</span></span></li>
    <li><span style="font-family: Fira Mono;"> xs.max <span style="color: #ef4b4b;">: Int</span></span></li>
    <li><span style="font-family: Fira Mono;">â†³xs.max<span style="color: #91b029;">(scala.math.Ordering.Int)</span> <span style="color: #ef4b4b;">: Int</span></span></li>
  </Appear>
</ul>

---

# Type parameter inference

```scala
def id[T](x: T): T = x
id(1) // How is this typed?
```
<ol>
<Appear>
<li><span style="color: #91b029;">Adapt</span> the expression by creating a <b style="color: #00a2b3;">type variable</b> for each missing type argument:</li>
<span><span style="font-family: Fira Mono;">id<span style="color: #91b029;">[</span><span style="color: #00a2b3;">T?</span><span style="color: #91b029;">]</span>(1)</span></span>
<li>Record the <b style="color: #ff80ae;">subtyping constraints</b> required for typechecking:</li>
<span><span style="font-family: Fira Mono;"><span style="color:
#00a2b3;">T?</span> <span style="color: #ff80ae;">&gt;: 1 &lt;: Any</span></span></span>
<li>Finally, <b style="color: #930077;">instantiate</b> the <span style="color: #00a2b3;">type variable</span> to a type that satisfies its <span style="color: #ff80ae;">constraints</span>:<br/>
    <span style="font-family: Fira Mono;"><span style="font-family: Fira Mono;">id<span style="color: #91b029;">[</span><span style="color: #930077;">Int</span><span style="color: #91b029;">]</span>(1)</span></span>
</li>
</Appear>
</ol>

---

# The art of <span style="color: #930077;">instantiation</span>

<ul>
<li><b>When</b> should a <span style="color:#00a2b3;">type variable</span> be <span style="color: #930077;">instantiated</span>?</li>
<ul>
<Appear>
<li>If <b>too early</b>: miss <span style="color: #ff80ae;">constraints</span></li>
<li>If <b>too late</b>: typechecking gets stuck</li>
<li>Solution: do it only when it's <b>safe</b> or when it's <b>forced</b></li>
</Appear>
</ul>
<li><b>What</b> should <span style="font-family: Fira Mono;"><span
style="color:#00a2b3;">T?</span> <span style="color: #ff80ae;">&gt;: Lo &lt;:
Hi</span></span> be <span style="color: #930077;">instantiated</span> to?</li>
<ul>
<Appear>
<span></span>
<span></span>
<span></span>
<li>If <span style="font-family: Fira Mono;"><span style="color:
#ff80ae;">Lo</span> =:= <span style="color: #ff80ae;">Hi</span></span>, just
pick one arbitrarily</li>
<li>Otherwise, depends on the <b>position</b> of <span style="font-family: Fira Mono; color:#00a2b3;">T?</span></li>
</Appear>
</ul>
</ul>

---

```scala
def foo[T](x: T): List[T]
```

To typecheck <span style="font-family: Fira Mono;">foo(1)</span>, we need to:

<ol>
<Appear>
<li><span style="color: #91b029;">Adapt</span> the expression:</li>
<center>
<span style="font-family: Fira Mono;">foo<span style="color:
#91b029;">[</span><span style="color: #00a2b3;">T?</span><span style="color:
#91b029;">]</span>(1)</span>
</center>
<li>Record the <span style="color: #ff80ae;">constraints</span>:</li>
<center>
<span style="font-family: Fira Mono;"><span style="color:
#00a2b3;">T?</span> <span style="color: #ff80ae;">&gt;: Int &lt;:
Any</span></span>
</center>
<li>Look at the result type:</li>
<center>
<span style="font-family: Fira
Mono;"><center>List[<span style="color:
#00a2b3;">T?</span>]</center></span>
</center>
<li>
<span style="color: #930077;">Instantiate</span> the <span style="color:#00a2b3;">type variable</span>:</li>
<center>
<span style="font-family: Fira Mono;"><span
style="color:#00a2b3;">T?</span> <span style="color: #930077;">:=
Int</span></span>
</center>
</Appear>
</ol>

---

```scala
def foo[T](x: T): T => Striâ€‹ng
```

To typecheck <span style="font-family: Fira Mono;">foo(1)</span>, we need to:

<ol>
<li><span style="color: #91b029;">Adapt</span> the expression:</li>
<center>
<span style="font-family: Fira Mono;">foo<span style="color:
#91b029;">[</span><span style="color: #00a2b3;">T?</span><span style="color:
#91b029;">]</span>(1)</span>
</center>
<li>Record the <span style="color: #ff80ae;">constraints</span>:</li>
<center>
<span style="font-family: Fira Mono;"><span style="color:
#00a2b3;">T?</span> <span style="color: #ff80ae;">&gt;: Int &lt;:
Any</span></span>
</center>
<li>Look at the result type:</li>
<center>
<span style="font-family: Fira
Mono; background-color: #e4f6bd;"><span style="color:
#00a2b3;">T?</span> => String</span>
</center>
<li>
<span style="color: #930077;">Instantiate</span> the <span
style="color:#00a2b3;">type variable</span>:</li>
<Appear>
<center>
<span style="font-family: Fira Mono;"><span
style="color:#00a2b3;">T?</span> <span style="color: #930077;">:=&nbsp;
<span style="background-color: #e4f6bd;">Any</span></span></span>
</center>
</Appear>
</ol>

---

```scala
def foo[T](x: T): T => T
```

To typecheck <span style="font-family: Fira Mono;">foo(1)</span>, we need to:

<ol>
<li><span style="color: #91b029;">Adapt</span> the expression:</li>
<center>
<span style="font-family: Fira Mono;">foo<span style="color:
#91b029;">[</span><span style="color: #00a2b3;">T?</span><span style="color:
#91b029;">]</span>(1)</span>
</center>
<li>Record the <span style="color: #ff80ae;">constraints</span>:</li>
<center>
<span style="font-family: Fira Mono;"><span style="color:
#00a2b3;">T?</span> <span style="color: #ff80ae;">&gt;: Int &lt;:
Any</span></span>
</center>
<li>Look at the result type:</li>
<center>
<span style="font-family: Fira
Mono; background-color: #e4f6bd;"><span style="color:
#00a2b3;">T?</span> => <span style="color: #00a2b3;">T?</span></span>
</center>
<Appear>
<li>
<b>Delay</b> the <span style="color:
#930077;">instantiation</span>.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<center>
<span style="font-family: Fira Mono; background-color: #e4f6bd;">Â¯\_(ãƒ„)_/Â¯</span>
</center>
</li>
</Appear>
</ol>

---

# When is instantiation safe?

```scala
def foo[T](â€¦): ResType = â€¦
foo[T?](â€¦) // T? >: Lo <: Hi
  .bar(â€¦)
```

<table class="fragment" data-fragment-index="3">
<tr>
<td><b>Positions</b> of T in ResType</td>
<td>Instantiation of T?</td>
</tr>
<tr>
<td>Not present</td>
<td>
<Appear>
<span>
Lo (arbitrary)
</span>
</Appear>
</td>
</tr>
<tr>
<td><b>co</b>variant</td>
<td>
<Appear>
<span></span>
<span>
Lo
</span>
</Appear>
</td>
</tr>
<tr>
<td><b>contra</b>variant</td>
<td>
<Appear>
<span></span>
<span></span>
<span>
Hi
</span>
</Appear>
</td>
</tr>
<tr>
<td><b>co</b>- <b>and</b> <b>contra</b>variant<br/> or <b>in</b>variant</td>
<td>
<Appear>
<span></span>
<span></span>
<span></span>
<span>
<b>Unsafe, delay</b>
</span>
</Appear>
</td>
</tr>
</table>

---

# When is instantiation forced?

<ul>
<Appear>
<li>When inferring a result type:</li>
<span>
<code class="language-scala">
val x = Array()
</code>
</span>
<li>When typing a lambda:</li>
<span>
<code class="language-scala">
foo(y => y + 1)
</code>
</span>
<span>
To typecheck the body of the lambda, we need to know the type of y.
</span>
<li>When performing an implicit search</li>
<li>â€¦ and a few other cases</li>
</Appear>
</ul>

---

# Forced instantiation

```scala
class Foo[A]
def id[T](x: Foo[T]): Foo[T] = x
val f = id(Foo(1))
```

<ol>
<Appear>
<li>id[T?](Foo[A?](1))</li>
<li>A? &gt;: Int</li>
<li>Foo[A?] &lt;: Foo[T?]</li>
<li>T? =: A?</li>
<li>Instantiation of A? is not safe but forced to give a type to f, which bound should we pick ?</li>
<li>A? =: Int</li>
<li>
<ol>
<li>
if a type variable is constrained in only one direction,<br/>
use that as the instantiation</li>
<li>Otherwise, use the lower bound</li>
</ol>
</li>
</Appear>
</ol>


---

# But is it actually better than Scala 2 ?

<ul>
<Appear>
<li>Hard to say: not much code written with Dotty yet.</li>
<li>Thread on <a href="https://contributors.scala-lang.org/t/better-type-inference-for-scala-send-us-your-problematic-cases/2410">contributors.scala-lang.org</a>:</li>
<span><img src={contributors} width="30%" /></span>
<li>Most of the code sent already work in Dotty!</li>
</Appear>
</ul>

---

# So what's different in Scala 2 ?

<ul>
<li><b>When</b> should a <span style="color:#00a2b3;">type variable</span> be <span style="color: #930077;">instantiated</span>?</li>
<ul>
<Appear>
<li>Scala 2 does it for every <span style="color:#00a2b3;">type variable</span> after <b>every parameter list</b> it types</li>
<li>â€¦ unless the instantiated type would be Nothing</li>
<li>This is sometimes <b>too late</b> and sometimes <b>too early</b></li>
</Appear>
</ul>
</ul>

---

# When Scala 2 is too late

```scala
def app1[T](x: T)(y: T => String) = y(x)
def app2[T](x: T, y: T => String) = y(x)


app1(1)((x: Int) => x.toString)

app1(1)(x => x.toString)
```

---

# When Scala 2 is too late

```scala
def app1[T](x: T)(y: T => String) = y(x)
def app2[T](x: T, y: T => String) = y(x)

// OK in Scala 2 and Dotty
app1(1)((x: Int) => x.toString)
// OK in Scala 2 and Dotty
app1(1)(x => x.toString)
```
---

# When Scala 2 is too late

```scala
def app1[T](x: T)(y: T => String) = y(x)
def app2[T](x: T, y: T => String) = y(x)


app2(1, (x: Int) => x.toString)

app2(1, x => x.toString)
```

---

# When Scala 2 is too late

```scala
def app1[T](x: T)(y: T => String) = y(x)
def app2[T](x: T, y: T => String) = y(x)

// OK in Scala 2 and Dotty
app2(1, (x: Int) => x.toString)
// Error in Scala 2, OK in Dotty
app2(1, x => x.toString)
```

---

# When Scala 2 is too early

```
class Foo1[T]() { def put(x: T) = {} }
class Foo2[T >: Null]() { def put(x: T) = {} }

new Foo1()

  .put("")

```

---

# When Scala 2 is too early

```
class Foo1[T]() { def put(x: T) = {} }
class Foo2[T >: Null]() { def put(x: T) = {} }

new Foo1()   // No instantiation
             // (to avoid T? =: Nothing)
  .put("")   // T? =: String

```

---

# When Scala 2 is too early

```
class Foo1[T]() { def put(x: T) = {} }
class Foo2[T >: Null]() { def put(x: T) = {} }

new Foo2()

  .put("")

```

---

# When Scala 2 is too early

```
class Foo1[T]() { def put(x: T) = {} }
class Foo2[T >: Null]() { def put(x: T) = {} }

new Foo2()   // T? =: Null

  .put("")   // error: type mismatch:
             //   Null does not match String
```

---

# The fear of Nothing ðŸ˜±

- Sometimes you really want to infer Nothing, but Scala 2 won't let you!
  ```scala
  class Foo[T]
  def foo[T](x: Foo[T]) = x
  foo(new Foo[Nothing]) // error in Scala 2
  ```

- Work around (used by fs2):
  ```scala
  type MyNothing <: Nothing
  ```
  See [Inference-Driven Design](https://mpilquist.github.io/blog/2018/07/04/fs2/) blog post by Michael Pilquist

---

# Menu

- Implicits
- Higher-kinded types
- Union types
- The foldLeft problem

---

# Implicits

- Do implicit search with tvars in type: ambiguous
- Do implicit search with all tvars instantiated: too restrictive
- Do implicit search with all previously constrained tvars instantiated: OK!

---

# Thank you!

