import { Head } from 'mdx-deck';
import { CodeSurferLayout } from "code-surfer";
import "prismjs/components/prism-java";
import "prismjs/components/prism-scala";

import { Mermaid } from "./mermaid";
import { Graphviz } from "./Graphviz";
import { Railroad } from "./Railroad";
import rr from "railroad-diagrams";

import { githubFull } from "code-surfer/themes";
import myTheme from './myTheme';

export const themes = [githubFull, myTheme]

<Head>
  <link rel="stylesheet"
  href={require("railroad-diagrams/railroad-diagrams.css")} />
  <link rel="stylesheet"
  href={require("./railroad-custom.css")} />
</Head>

# :evergreen_tree: :evergreen_tree: :evergreen_tree:

# Future-proofing Scala through TASTY

Guillaume Martres - EPFL

# :evergreen_tree: :evergreen_tree: :evergreen_tree:

---

# Tasty binary format

<Railroad diagram={
rr.Diagram(rr.Stack(
  rr.Sequence("0x5CA1AB1F", "Major Version", "Minor Version"),
  rr.Sequence("NameTable", rr.OneOrMore("Section"))
))
} />

---

# NameTable

<Railroad diagram={
rr.Diagram("Length", rr.OneOrMore("Name"))
} />

---

# Tasty binary format

- xx copy from prev presentation
- preserve all information that cannot be recreated
- make sure useful info has not been lost in a previous phase (final val)

---

# Compiler pipeline

<Graphviz dot={[`
digraph {
bgcolor=transparent;
rankdir=LR;
node [fontsize="28.0", fontname="Source Sans Pro", shape="box"];
magic [label="✨Magic✨"];
src [label="Hello.scala", shape="note"];
dst [label="Hello.class", shape="note"];
{ rank=same src magic dst }
src -> magic -> dst;
}
`,
`
digraph {
bgcolor=transparent;
rankdir=LR;
node [fontsize="28.0", fontname="Source Sans Pro", shape="box"];
magic [label="✨Magic✨"];
src [label="Hello.scala", shape="note"];
dst [label="Hello.class", shape="note"];
{ rank=same src Parser }
{ rank=same magic dst }
src -> Parser -> magic -> dst;
}
`]} />

---

# Compiler pipeline

<Graphviz dot={[`
digraph {
bgcolor=transparent;
rankdir=LR;
node [fontsize="28.0", fontname="Source Sans Pro", shape="box"];
me [label="Middle-End"];
src [label="Hello.scala", shape="note"];
tst [label="Hello.tasty", shape="note"];
dst [label="Hello.class", shape="note"];
{ rank=same src Parser }
{ rank=same Pickler tst }
{ rank=same Backend dst }
src -> Parser -> Typer -> Pickler -> me -> Backend -> dst;
Pickler -> tst;
}
`]} />

---

# Untyped Tree

<Mermaid params={{ theme: "forest" }} chart={`
graph TB;
app(Apply) --> sel(Select);
app --> lit("Literal");
lit --> 5("5");
sel --> id("Ident(''obj'')");
sel --> fun("''meth''");
`} />

---

<CodeSurferLayout>

```scala
obj.meth(5)
```

```scala 1[1:3],3,6[1:16]
obj.meth(5)

// Parser output:
Apply(
  Select(
    Ident("obj"),
    "meth"
  ),
  Literal(5)
)
```

```scala 1[4],5,8[1:3]
obj.meth(5)

// Parser output:
Apply(
  Select(
    Ident("obj"),
    "meth"
  ),
  Literal(5)
)
```

```scala 1[5:8],7
obj.meth(5)

// Parser output:
Apply(
  Select(
    Ident("obj"),
    "meth"
  ),
  Literal(5)
)
```

```scala 1[9,11],4,10
obj.meth(5)

// Parser output:
Apply(
  Select(
    Ident("obj"),
    "meth"
  ),
  Literal(5)
)
```

```scala 1[10],9
obj.meth(5)

// Parser output:
Apply(
  Select(
    Ident("obj"),
    "meth"
  ),
  Literal(5)
)
```
</CodeSurferLayout>
