import { Appear, Head } from 'mdx-deck';
import { CodeSurferLayout } from "code-surfer";
import "prismjs/components/prism-java";
import "prismjs/components/prism-scala";

import { Graphviz } from "./Graphviz";
import { Railroad, Red } from "./Railroad";
import rr from "railroad-diagrams";

import { github } from "code-surfer";

import { dark, prism } from 'mdx-deck/themes';
import myTheme from './myTheme';

export const themes = [prism, myTheme];

import "./custom.css";

import contributors from "./contributors.png";
import si2712a from "./si2712a.png";

# Scala 3, type inference and you!

Guillaume Martres - EPFL

---

# Scala compiler pipeline

<Graphviz dot={[
`
digraph {
bgcolor=transparent;
rankdir=LR;
node [fontsize="38.0", fontname="Source Sans Pro, Noto Color Emoji", shape="box"];
magic [label="âœ¨ Magic âœ¨", style="filled", fillcolor="#d6c8ff"];
src [label="Hello.scala", shape="note", style="filled", fillcolor="#f8f3d4"];
dst [label="Hello.class", shape="note", style="filled", fillcolor="#f8f3d4"];
{ rank=same src magic dst }
src -> magic -> dst;
}
`,
`
digraph {
bgcolor=transparent;
rankdir=LR;
node [fontsize="38.0", fontname="Source Sans Pro, Noto Color Emoji", shape="box"];
magic [label="âœ¨ Magic âœ¨", style="filled", fillcolor="#d6c8ff"];
src [label="Hello.scala", shape="note", style="filled", fillcolor="#f8f3d4"];
dst [label="Hello.class", shape="note", style="filled", fillcolor="#f8f3d4"];
Parser [ style="bold", color="#ef4b4b"];
{ rank=same src Parser }
{ rank=same magic dst }
src -> Parser -> magic -> dst;
}
`,
]} />

---

# Parsing

<Graphviz dot={[
`
digraph {
margin=1.0;
bgcolor=transparent;
labelloc="t";
fontname="Fira Mono";
fontsize="50.0";
label=< <b>foo</b>  <b>.elem(5)</b>  >;
}
`,
`
digraph {
margin=1.0;
bgcolor=transparent;
rankdir=TB;
node [shape="box", fontname="Source Sans Pro, Noto Color Emoji", fontsize="38.0", style="rounded, filled", fillcolor="#cde498"];
foo [label="\\\"foo\\\"", style="filled", fontcolor="#b36232"]
Ident -> foo
labelloc="t";
fontname="Fira Mono";
fontsize="50.0";
label=< <b>foo</b>  >;
}
`,
`
digraph {
margin=0.5;
bgcolor=transparent;
rankdir=TB;
node [shape="box", fontname="Source Sans Pro, Noto Color Emoji", fontsize="38.0", style="rounded, filled"];
foo [label="\\\"foo\\\"", style="filled", fontcolor="#b36232"]
Ident -> foo
node [fillcolor="#cde498"];
elem [label="\\\"elem\\\"", style="filled", fontcolor="#b36232"]
Select -> Ident
Select -> elem
labelloc="t";
fontname="Fira Mono";
fontsize="50.0";
label=<             <b>foo.elem</b>                    >;
}
`,
`
digraph {
bgcolor=transparent;
rankdir=TB;
node [shape="box", fontname="Source Sans Pro, Noto Color Emoji", fontsize="38.0", style="rounded, filled"];
foo [label="\\\"foo\\\"", style="filled", fontcolor="#b36232"]
Ident -> foo
elem [label="\\\"elem\\\"", style="filled", fontcolor="#b36232"]
Select -> Ident
Select -> elem
node [fillcolor="#cde498"];
5 [style="filled", fontcolor="#b36232"]
  Apply -> Select
Apply -> Literal -> 5
labelloc="t";
fontname="Fira Mono";
fontsize="50.0";
label=<             <b>foo.elem(5)</b>                    >;
}
`,
]} />

---

<Graphviz dot={[
`
digraph {
bgcolor=transparent;
rankdir=LR;
node [fontsize="38.0", fontname="Source Sans Pro, Noto Color Emoji", shape="box"];
magic [label="âœ¨ Magic âœ¨", style="filled", fillcolor="#d6c8ff"];
src [label="Hello.scala", shape="note", style="filled", fillcolor="#f8f3d4"];
dst [label="Hello.class", shape="note", style="filled", fillcolor="#f8f3d4"];
{ rank=same src Parser }
{ rank=same magic dst }
src -> Parser -> magic -> dst;
}
`,
`
digraph {
bgcolor=transparent;
rankdir=LR;
node [fontsize="38.0", fontname="Source Sans Pro, Noto Color Emoji", shape="box"];
magic [label="âœ¨ Magic âœ¨", style="filled", fillcolor="#d6c8ff"];
src [label="Hello.scala", shape="note", style="filled", fillcolor="#f8f3d4"];
dst [label="Hello.class", shape="note", style="filled", fillcolor="#f8f3d4"];
Typer [ style="bold", color="#ef4b4b"];
{ rank=same src Parser }
{ rank=same magic dst }
src -> Parser -> Typer -> magic -> dst;
}
`,
]} />

---

# Typing

```scala
class A {
  def elem(x: Int): Int
  def elem(x: String): String
}
val foo: A
// Expression to type
foo.elem(5)
```

---

# Typing

<Graphviz dot={[
`
digraph {
bgcolor=transparent;
rankdir=TB;
node [shape="box", fontname="Source Sans Pro, Noto Color Emoji", fontsize="38.0", style="rounded, filled"];
foo [label="\\\"foo\\\"", style="filled", fontcolor="#b36232"]
Ident -> foo
elem [label="\\\"elem\\\"", style="filled", fontcolor="#b36232"]
Select -> Ident
Select -> elem
5 [style="filled", fontcolor="#b36232"]
Apply -> Select
Apply -> Literal
Literal -> 5
}
`,
`
digraph {
bgcolor=transparent;
rankdir=TB;
node [shape="box", fontname="Source Sans Pro, Noto Color Emoji", fontsize="38.0", style="rounded, filled"];
foo [label="\\\"foo\\\"", style="filled", fontcolor="#b36232"]
Ident -> foo
elem [label="\\\"elem\\\"", style="filled", fontcolor="#b36232"]
Select -> Ident
Select -> elem
5 [style="filled", fontcolor="#b36232"]
Apply -> Select [color="#ef4b4b", fontcolor="#ef4b4b", label="?(...)"];
Apply -> Literal
Literal -> 5
}
`,
`
digraph {
bgcolor=transparent;
rankdir=TB;
node [shape="box", fontname="Source Sans Pro, Noto Color Emoji", fontsize="38.0", style="rounded, filled"];
foo [label="\\\"foo\\\"", style="filled", fontcolor="#b36232"]
Ident -> foo
elem [label="\\\"elem\\\"", style="filled", fontcolor="#b36232"]
Select -> Ident [color="#ef4b4b"];
Select -> elem
5 [style="filled", fontcolor="#b36232"]
Apply -> Select [color="#ef4b4b", fontcolor="#ef4b4b", label="?(...)"];
Apply -> Literal
Literal -> 5
}
`,
`
digraph {
bgcolor=transparent;
rankdir=TB;
node [shape="box", fontname="Source Sans Pro, Noto Color Emoji", fontsize="38.0", style="rounded, filled"];
foo [label="\\\"foo\\\"", style="filled", fontcolor="#b36232"]
    Ident [shape="record", label="Ident | foo.type", fillcolor="#fae3d9"]
Ident -> foo
elem [label="\\\"elem\\\"", style="filled", fontcolor="#b36232"]
Select -> Ident [color="#ef4b4b", fontcolor="#ef4b4b", label="?.elem"];
Select -> elem
5 [style="filled", fontcolor="#b36232"]
Apply -> Select [color="#ef4b4b", fontcolor="#ef4b4b", label="?(...)"];
Apply -> Literal
Literal -> 5
}
`,
`
digraph {
bgcolor=transparent;
rankdir=TB;
node [shape="box", fontname="Source Sans Pro, Noto Color Emoji", fontsize="38.0", style="rounded, filled"];
foo [label="\\\"foo\\\"", style="filled", fontcolor="#b36232"]
Ident [shape="record", label="Ident | foo.type", fillcolor="#fae3d9"]
Select [shape="record", label="Select | foo.elem.type", fillcolor="#fae3d9"]
Ident -> foo
elem [label="\\\"elem\\\"", style="filled", fontcolor="#b36232"]
Select -> Ident;
Select -> elem
5 [style="filled", fontcolor="#b36232"]
Apply -> Select [color="#ef4b4b", fontcolor="#ef4b4b", label="?(...)"];
Apply -> Literal
Literal -> 5
}
`,
`
digraph {
bgcolor=transparent;
rankdir=TB;
node [shape="box", fontname="Source Sans Pro, Noto Color Emoji", fontsize="38.0", style="rounded, filled"];
foo [label="\\\"foo\\\"", style="filled", fontcolor="#b36232"]
Ident [shape="record", label="Ident | foo.type", fillcolor="#fae3d9"]
Select [shape="record", label="Select | foo.elem.type", fillcolor="#fae3d9"]
Literal [shape="record", label="Literal | 5", fillcolor="#fae3d9"]
Ident -> foo
elem [label="\\\"elem\\\"", style="filled", fontcolor="#b36232"]
Select -> Ident;
Select -> elem
5 [style="filled", fontcolor="#b36232"]
Apply -> Select [color="#ef4b4b", fontcolor="#ef4b4b", label="?(Int)"];
Apply -> Literal;
Literal -> 5
}
`,
`
digraph {
bgcolor=transparent;
rankdir=TB;
node [shape="box", fontname="Source Sans Pro, Noto Color Emoji", fontsize="38.0", style="rounded, filled"];
foo [label="\\\"foo\\\"", style="filled", fontcolor="#b36232"]
Ident [shape="record", label="Ident | foo.type", fillcolor="#fae3d9"]
Select [shape="record", label="Select | foo.elem.type", fillcolor="#fae3d9"]
Literal [shape="record", label="Literal | 5", fillcolor="#fae3d9"]
Ident -> foo
elem [label="\\\"elem\\\"", style="filled", fontcolor="#b36232"]
Select -> Ident;
Select -> elem
5 [style="filled", fontcolor="#b36232"]
Apply -> Select [color="#ef4b4b", fontcolor="#ef4b4b", label="?(Int)"];
Apply -> Literal;
Literal -> 5
}
`,
`
digraph {
bgcolor=transparent;
rankdir=TB;
node [shape="box", fontname="Source Sans Pro, Noto Color Emoji", fontsize="38.0", style="rounded, filled"];
foo [label="\\\"foo\\\"", style="filled", fontcolor="#b36232"]
Ident [shape="record", label="Ident | foo.type", fillcolor="#fae3d9"]
Select [shape="record", label="Select | foo.elem.type \\(Int \\=\\> Int\\)", fillcolor="#fae3d9"]
Literal [shape="record", label="Literal | 5", fillcolor="#fae3d9"]
Ident -> foo
elem [label="\\\"elem\\\"", style="filled", fontcolor="#b36232"]
Select -> Ident;
Select -> elem
5 [style="filled", fontcolor="#b36232"]
Apply -> Select;
Apply -> Literal;
Literal -> 5
}
`,
`
digraph {
bgcolor=transparent;
rankdir=TB;
node [shape="box", fontname="Source Sans Pro, Noto Color Emoji", fontsize="38.0", style="rounded, filled"];
foo [label="\\\"foo\\\"", style="filled", fontcolor="#b36232"]
Ident [shape="record", label="Ident | foo.type", fillcolor="#fae3d9"]
Select [shape="record", label="Select | foo.elem.type", fillcolor="#fae3d9"]
Literal [shape="record", label="Literal | 5", fillcolor="#fae3d9"]
Apply [shape="record", label="Apply | Int", fillcolor="#fae3d9"]
Ident -> foo
elem [label="\\\"elem\\\"", style="filled", fontcolor="#b36232"]
Select -> Ident;
Select -> elem
5 [style="filled", fontcolor="#b36232"]
Apply -> Select
Apply -> Literal
Literal -> 5
}
`,
]} />

---

# What if there's a type mismatch ?

<ul>
  The <b>computed type</b> of a tree might not match its <b
  style="color: #ef4b4b;">expected type</b>.<br/>
  <Appear>
    <span>When this happens, the typechecker will attempt to <b style="color: #91b029;">adapt</b> the tree.</span>
    <li><span style="font-family: Fira Mono;">List<span style="color: #ef4b4b;">(1, 2)</span></span></li>
    <li><span style="font-family: Fira Mono;">â†³List<span style="color: #91b029;">.apply</span><span style="color: #ef4b4b;">(1, 2)</span></span></li>
    <li><span style="font-family: Fira Mono;"> xs.max <span style="color: #ef4b4b;">: Int</span></span></li>
    <li><span style="font-family: Fira Mono;">â†³xs.max<span style="color: #91b029;">(scala.math.Ordering.Int)</span> <span style="color: #ef4b4b;">: Int</span></span></li>
  </Appear>
</ul>

---

# Type parameter inference

```scala
def id[T](x: T): T = x
id(1) // How is this typed?
```
<ol>
<Appear>
<li><span style="color: #91b029;">Adapt</span> the expression by creating a <b style="color: #00a2b3;">type variable</b> for each missing type argument:</li>
<span><span style="font-family: Fira Mono;">id<span style="color: #91b029;">[</span><span style="color: #00a2b3;">T?</span><span style="color: #91b029;">]</span>(1)</span></span>
<li>Record the <b style="color: #ff80ae;">subtyping constraints</b> required for typechecking:</li>
<span><span style="font-family: Fira Mono;"><span style="color:
#00a2b3;">T?</span> <span style="color: #ff80ae;">&gt;: 1 &lt;: Any</span></span></span>
<li>Finally, <b style="color: #930077;">instantiate</b> the <span style="color: #00a2b3;">type variable</span> to a type that satisfies its <span style="color: #ff80ae;">constraints</span>:<br/>
    <span style="font-family: Fira Mono;"><span style="font-family: Fira Mono;">id<span style="color: #91b029;">[</span><span style="color: #930077;">Int</span><span style="color: #91b029;">]</span>(1)</span></span>
</li>
</Appear>
</ol>

---

# The art of <span style="color: #930077;">instantiation</span>

<ul>
<li><b>When</b> should a <span style="color:#00a2b3;">type variable</span> be <span style="color: #930077;">instantiated</span>?</li>
<ul>
<Appear>
<li>If <b>too early</b>: miss <span style="color: #ff80ae;">constraints</span></li>
<li>If <b>too late</b>: typechecking gets stuck</li>
<li>Solution: do it only when it's <b>safe</b> or when it's <b>forced</b></li>
</Appear>
</ul>
<li><b>What</b> should <span style="font-family: Fira Mono;"><span
style="color:#00a2b3;">T?</span> <span style="color: #ff80ae;">&gt;: Lo &lt;:
Hi</span></span> be <span style="color: #930077;">instantiated</span> to?</li>
<ul>
<Appear>
<span></span>
<span></span>
<span></span>
<li>If <span style="font-family: Fira Mono;"><span style="color:
#ff80ae;">Lo</span> =:= <span style="color: #ff80ae;">Hi</span></span>, just
pick one arbitrarily</li>
<li>Otherwise, depends on the <b>position</b> of <span style="font-family: Fira Mono; color:#00a2b3;">T?</span></li>
</Appear>
</ul>
</ul>

---

```scala
def foo[T](x: T): List[T]
```

To typecheck <span style="font-family: Fira Mono;">foo(1)</span>, we need to:

<ol>
<Appear>
<li><span style="color: #91b029;">Adapt</span> the expression:</li>
<center>
<span style="font-family: Fira Mono;">foo<span style="color:
#91b029;">[</span><span style="color: #00a2b3;">T?</span><span style="color:
#91b029;">]</span>(1)</span>
</center>
<li>Record the <span style="color: #ff80ae;">constraints</span>:</li>
<center>
<span style="font-family: Fira Mono;"><span style="color:
#00a2b3;">T?</span> <span style="color: #ff80ae;">&gt;: Int &lt;:
Any</span></span>
</center>
<li>Look at the result type:</li>
<center>
<span style="font-family: Fira
Mono;"><center>List[<span style="color:
#00a2b3;">T?</span>]</center></span>
</center>
<li>
<span style="color: #930077;">Instantiate</span> the <span style="color:#00a2b3;">type variable</span>:</li>
<center>
<span style="font-family: Fira Mono;"><span
style="color:#00a2b3;">T?</span> <span style="color: #930077;">:=
Int</span></span>
</center>
</Appear>
</ol>

---

```scala
def foo[T](x: T): T => Striâ€‹ng
```

To typecheck <span style="font-family: Fira Mono;">foo(1)</span>, we need to:

<ol>
<li><span style="color: #91b029;">Adapt</span> the expression:</li>
<center>
<span style="font-family: Fira Mono;">foo<span style="color:
#91b029;">[</span><span style="color: #00a2b3;">T?</span><span style="color:
#91b029;">]</span>(1)</span>
</center>
<li>Record the <span style="color: #ff80ae;">constraints</span>:</li>
<center>
<span style="font-family: Fira Mono;"><span style="color:
#00a2b3;">T?</span> <span style="color: #ff80ae;">&gt;: Int &lt;:
Any</span></span>
</center>
<li>Look at the result type:</li>
<center>
<span style="font-family: Fira
Mono; background-color: #e4f6bd;"><span style="color:
#00a2b3;">T?</span> => String</span>
</center>
<li>
<span style="color: #930077;">Instantiate</span> the <span
style="color:#00a2b3;">type variable</span>:</li>
<Appear>
<center>
<span style="font-family: Fira Mono;"><span
style="color:#00a2b3;">T?</span> <span style="color: #930077;">:=&nbsp;
<span style="background-color: #e4f6bd;">Any</span></span></span>
</center>
</Appear>
</ol>

---

```scala
def foo[T](x: T): T => T
```

To typecheck <span style="font-family: Fira Mono;">foo(1)</span>, we need to:

<ol>
<li><span style="color: #91b029;">Adapt</span> the expression:</li>
<center>
<span style="font-family: Fira Mono;">foo<span style="color:
#91b029;">[</span><span style="color: #00a2b3;">T?</span><span style="color:
#91b029;">]</span>(1)</span>
</center>
<li>Record the <span style="color: #ff80ae;">constraints</span>:</li>
<center>
<span style="font-family: Fira Mono;"><span style="color:
#00a2b3;">T?</span> <span style="color: #ff80ae;">&gt;: Int &lt;:
Any</span></span>
</center>
<li>Look at the result type:</li>
<center>
<span style="font-family: Fira
Mono; background-color: #e4f6bd;"><span style="color:
#00a2b3;">T?</span> => <span style="color: #00a2b3;">T?</span></span>
</center>
<Appear>
<li>
<b>Delay</b> the <span style="color:
#930077;">instantiation</span>.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<center>
<span style="font-family: Fira Mono; background-color: #e4f6bd;">Â¯\_(ãƒ„)_/Â¯</span>
</center>
</li>
</Appear>
</ol>

---

# When is instantiation safe?

```scala
def foo[T](â€¦): ResType = â€¦
foo[T?](â€¦) // T? >: Lo <: Hi
  .bar(â€¦)
```

<table class="fragment" data-fragment-index="3">
<tr>
<td><b>Positions</b> of T in ResType</td>
<td>Instantiation of T?</td>
</tr>
<tr>
<td>Not present</td>
<td>
<Appear>
<span>
Lo (arbitrary)
</span>
</Appear>
</td>
</tr>
<tr>
<td><b>co</b>variant</td>
<td>
<Appear>
<span></span>
<span>
Lo
</span>
</Appear>
</td>
</tr>
<tr>
<td><b>contra</b>variant</td>
<td>
<Appear>
<span></span>
<span></span>
<span>
Hi
</span>
</Appear>
</td>
</tr>
<tr>
<td><b>co</b>- <b>and</b> <b>contra</b>variant<br/> or <b>in</b>variant</td>
<td>
<Appear>
<span></span>
<span></span>
<span></span>
<span>
<b>Unsafe, delay</b>
</span>
</Appear>
</td>
</tr>
</table>

---

# When is instantiation forced?

<ul>
<Appear>
<li>When inferring a result type:</li>
<span>
<code class="language-scala">
val x = Array()
</code>
</span>
<li>When typing a lambda:</li>
<span>
<code class="language-scala">
foo(y => y + 1)
</code>
</span>
<span>
To typecheck the body of the lambda, we need to know the type of y.
</span>
<li>When performing an implicit search</li>
<li>â€¦ and a few other cases</li>
</Appear>
</ul>

---

# Forced instantiation

```scala
class Foo[A]
def id[T](x: Foo[T]): Foo[T] = x
val f = id(Foo(1))
```

<ol>
<Appear>
<li>id[T?](Foo[A?](1))</li>
<li>A? &gt;: Int</li>
<li>Foo[A?] &lt;: Foo[T?]</li>
<li>T? =: A?</li>
<li>Instantiation of A? is not safe but forced to give a type to f, which bound should we pick ?</li>
<li>A? =: Int</li>
<li>
<ol>
<li>
if a type variable is constrained in only one direction,<br/>
use that as the instantiation</li>
<li>Otherwise, use the lower bound</li>
</ol>
</li>
</Appear>
</ol>


---

# But is it actually better than Scala 2 ?

<ul>
<Appear>
<li>Hard to say: not much code written with Dotty yet.</li>
<li>Thread on <a href="https://contributors.scala-lang.org/t/better-type-inference-for-scala-send-us-your-problematic-cases/2410">contributors.scala-lang.org</a>:</li>
<span><img src={contributors} width="30%" /></span>
<li>Most of the code sent already work in Dotty!</li>
</Appear>
</ul>

---

# So what's different in Scala 2 ?

<ul>
<li><b>When</b> should a <span style="color:#00a2b3;">type variable</span> be <span style="color: #930077;">instantiated</span>?</li>
<ul>
<Appear>
<li>Scala 2 does it for every <span style="color:#00a2b3;">type variable</span> after <b>every parameter list</b> it types</li>
<li>â€¦ unless the instantiated type would be Nothing</li>
<li>This is sometimes <b>too late</b> and sometimes <b>too early</b></li>
</Appear>
</ul>
</ul>

---

# When Scala 2 is too late

```scala
def app1[T](x: T)(y: T => String) = y(x)
def app2[T](x: T, y: T => String) = y(x)


app1(1)((x: Int) => x.toString)

app1(1)(x => x.toString)
```

---

# When Scala 2 is too late

```scala
def app1[T](x: T)(y: T => String) = y(x)
def app2[T](x: T, y: T => String) = y(x)

// OK in Scala 2 and Dotty
app1(1)((x: Int) => x.toString)
// OK in Scala 2 and Dotty
app1(1)(x => x.toString)
```
---

# When Scala 2 is too late

```scala
def app1[T](x: T)(y: T => String) = y(x)
def app2[T](x: T, y: T => String) = y(x)


app2(1, (x: Int) => x.toString)

app2(1, x => x.toString)
```

---

# When Scala 2 is too late

```scala
def app1[T](x: T)(y: T => String) = y(x)
def app2[T](x: T, y: T => String) = y(x)

// OK in Scala 2 and Dotty
app2(1, (x: Int) => x.toString)
// Error in Scala 2, OK in Dotty
app2(1, x => x.toString)
```

---

# When Scala 2 is too early

```
class Foo1[T]() { def put(x: T) = {} }
class Foo2[T >: Null]() { def put(x: T) = {} }

new Foo1()

  .put("")

```

---

# When Scala 2 is too early

```
class Foo1[T]() { def put(x: T) = {} }
class Foo2[T >: Null]() { def put(x: T) = {} }

new Foo1()   // No instantiation
             // (to avoid T? =: Nothing)
  .put("")   // T? =: String

```

---

# When Scala 2 is too early

```
class Foo1[T]() { def put(x: T) = {} }
class Foo2[T >: Null]() { def put(x: T) = {} }

new Foo2()

  .put("")

```

---

# When Scala 2 is too early

```
class Foo1[T]() { def put(x: T) = {} }
class Foo2[T >: Null]() { def put(x: T) = {} }

new Foo2()   // T? =: Null

  .put("")   // error: type mismatch:
             //   Null does not match String
```

---

# The fear of Nothing ðŸ˜±

- Sometimes you really want to infer Nothing, but Scala 2 won't let you!
  ```scala
  class Foo[T]
  def foo[T](x: Foo[T]) = x
  foo(new Foo[Nothing]) // error in Scala 2
  ```

- Work around (used by fs2):
  ```scala
  type MyNothing <: Nothing
  ```
  See [Inference-Driven Design](https://mpilquist.github.io/blog/2018/07/04/fs2/) blog post by Michael Pilquist

---

# Menu of advanced topics

- Implicit search
- Higher-kinded types
- Union types
- The `foldLeft` problem

---

# Implicit search and type variables

```scala
def foo[T](x: T)(implicit ev: Foo[T]): â€¦

foo[T?](a)
```

Should we force the instantiation of `T?` before doing the implicit search ?


- Do implicit search with tvars in type: ambiguous
- Do implicit search with all tvars instantiated: too restrictive
- Do implicit search with all previously constrained tvars instantiated: OK!

---

# Attempt 1: force instantation of all tvars

Usually fine, except when encoding **functional dependencies**:

```scala
Matrix * Matrix => Matrix
Matrix * Vector => Vector
Matrix * Int    => Matrix
   Int * Matrix => Matrix
```

---

```scala
trait MultDep[A, B, C] {
  def apply(a: A, b: B): C
}
implicit object mmm extends MultDep[Matrix, Matrix, Matrix] {
  def apply(a: Matrix, b: Matrix): Matrix = â€¦
}
implicit object mvv extends MultDep[Matrix, Vector, Vector] {
  def apply(a: Matrix, b: Vector): Vector = â€¦
}
```

---

```scala
def mult[A, B, C](a: A, b: B)(
  implicit ev: MultDep[A, B, C]): C = ev(a, b)

mult(matrix1, matrix2) // : Matrix
mult(matrix1, vector1) // : Vector
```
---

```scala
def mult[A, B, C](a: A, b: B)(
  implicit ev: MultDep[A, B, C]): C = ev(a, b)

```

- mult[?A, ?B, ?C](matrix1, vector1)
- ?A >: Matrix
- ?B >: Vector
- ?C >: Nothing <: Any
- Implicit search for MultDep[?A, ?B, ?C]
- After instantiation: MultDep[Matrix, Vector, Nothing]
- Implicit not found!

---

# Attempt 2: Keep type variables as-is

- Directly do an implicit search for `MultDep[?A, ?B, ?C]`
- `mvv <: MultDep[?A, ?B, ?C]`
- `MultDep[Matrix, Vector, Vector] <: MultDep[?A, ?B, ?C]`
- `?A := Matrix, ?B := Vector, ?C := Vector`
- Pick `mvv`

---

```scala
def foo[T](x: T)(implicit ev: Foo[T]): â€¦

implicit val a: Foo[Int] = â€¦
implicit val b: Foo[Any] = â€¦

foo(1)
```

- T? >: Int
- Both `a` and `b` match the type: ambiguous implicit!

---

# Solution

- Only instantiate constrained type variables!
- mult[?A, ?B, ?C](matrix1, vector1)
- ?A >: Matrix
- ?B >: Vector
- ?C unconstrained
- Implicit search for MultDep[Matrix, Vector, ?C]
- `mvv <: MultDep[Matrix, Vector, ?C]`
- `MultDep[Matrix, Vector, Vector] <: MultDep[?A, ?B, ?C]`
- `?C := Vector`
- Pick `mvv`

---

# Higher-kinded types

Type variables can be higher-kinded too:

```scala
def foo[F[_]](fi: F[Int]): ...
val ii: (Int, Int)
foo(ii)
```

- `foo[?F](ii)`
- `?F[Int] >: (Int, Int)`
- ðŸ¤”
- `?F := [X] =>> (X, X)`
- `?F := [X] =>> (Int, X)`
- `?F := [X] =>> (X, Int)`
- `?F := [X] =>> (Int, Int)`

---

What should we instantiate `?F` to ?
```scala
?F =: [X] =>> X => X
?F =: [X] =>> X => X
?F =: [X] =>> X => X
?F =: [X] =>> X => X
```

---

- This is higher-order unification
- Undecidable in general
- Huet's algorithm: semi-decidable (might not terminate if there's no solution)
-  ðŸ¤” ðŸ¤” ðŸ¤”

---

# The infamous SI-2712

<img src={si2712a} width="70%" />

---

# Union types

```scala
if (cond)
  1
else
  true
```

- Typed as `Int | Boolean`

---

# Why do we need union types ?

```scala
trait A { type T <: A }
trait B { type T <: B }
class C extends A with B { type T <: C }
class D extends A with B { type T <: D }
val x = if (cond) new C else new D
```
What's the type of `x` ? We want the <b>least upper bound</b> of `C` and `D`.
In Scala 2:
```scala
A with B { type T <: (A with B { type T <: (...
```
Infinite.
In Dotty:
```scala
C | D
```

---

# When should we infer unions ?

Inferring a type which is "too precise" is sometimes problematic:

```scala
trait Base
class A extends Base
class B extends Base
class C extends Base
var x = if (cond) new A else new B
x = new C
```
If we infer the type of `x` to be `A | B`, then the last line will fail
Solution: widen the type to a non-union.

---

# Should we preserve unions more often ?

```scala
val x: A | B = ...
val y = x
val z: A | B = y
```
- Intuitively, we want to avoid widening user-written unions
- https://github.com/lampepfl/dotty/issues/4867

---

# The `foldLeft` problem

```scala
val xs: List[Int]
xs.foldLeft(Nil)((acc, x) => x :: acc)
```

---

# Thank you!

